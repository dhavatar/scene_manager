class_name SceneManagerData
## Data class for storing information about the scene properties.
##
## Handles storing scene information along with some editor properties and
## handles saving/loading the data from the `scene.gd` file.

# Project Settings property name
const ROOT_ADDRESS = "res://"

# Data dictionary keys
const INCLUDE_LIST_KEY := "_include_list"
const SCENE_DATA_KEY := "_scenes"
const SECTIONS_KEY := "_sections"

# scene.gd autogen file tags
const SCENE_DATA_HEADER: String = "#\n\
# This file is autogenerated by the Scene Manager plugin.\n\
# DO NOT EDIT.\n\
#\n\
@tool\n\
extends Node\n\n"
const SCENE_DATA_ENUM: String = "# [Scene Enum]"
const SCENE_DATA_DICTIONARY: String = "# [Scene Dictionary]"
const SCENE_DATA_END_DICTIONARY: String = "# [End Scene Dictionary]"

# A dictionary cache which contains every scenes exact addresses as key and an array 
# assigned as values which categories every section name the scene is part of
#
# Example: { "res://demo/scene3.tscn": ["Character", "Menu"] }
var _sections: Dictionary = {}
var _data: Dictionary = {} # Main data storage for all settings
var _file_data: Dictionary = {} # Current data in the file to use when comparing against the data


#region Accessors to the dictionary data

## Whether or not the editor plugin will auto save.
var auto_save: bool:
	get:
		return ProjectSettings.get_setting(SceneManagerConstants.SETTINGS_AUTO_SAVE_PROPERTY_NAME, false)
	set(value):
		ProjectSettings.set_setting(SceneManagerConstants.SETTINGS_AUTO_SAVE_PROPERTY_NAME, value)
		ProjectSettings.save()


## Returns the scenes from `scenes` variable of `scenes.gd` file
var scenes: Dictionary:
	get:
		return _data[SCENE_DATA_KEY]


## Returns the array value of `_include_list` key from `scenes` variable of `scenes.gd` file
var includes: Array:
	get:
		return _data[INCLUDE_LIST_KEY]


## Returns the array value of `_sections` key from `scenes` variable of `scenes.gd` file
var sections: Array:
	get:
		return _data[SECTIONS_KEY]


## Returns true if there's been changes that haven't been saved.
var has_changes: bool:
	get:
		return not _file_data.recursive_equal(_data, 3)

#endregion Accessors


## Adds the include path to the data, which is where the scene manager will look for scenes.
func add_include_path(path: String) -> void:
	includes.append(path)
	_refresh_scenes()


## Removes the include from the data to exclude it from the scene manager search path.
func remove_include_path(path: String) -> void:
	includes.erase(path)
	_remove_scenes(path)


## Adds the scene to the specified subsection.
func add_to_subsection(scene_address: String, section_name: String, sub_section: String) -> void:
	for key in scenes:
		if scenes[key]["value"] == scene_address:
			scenes[key]["settings"][section_name]["subsection"] = sub_section
			break


## Removes the scene from the specified subsection.
func remove_from_subsection(scene_address: String, section_name: String, sub_section: String) -> void:
	for key in scenes:
		if scenes[key]["value"] == scene_address:
			scenes[key]["settings"][section_name]["subsection"] = ""
			break


## Changes the scene key name in the data
func change_name(old_scene_name: String, new_scene_name: String) -> void:
	scenes[new_scene_name] = scenes[old_scene_name]
	scenes.erase(old_scene_name)

#region Section Handler


## Adds a new section
func add_section(section_name: String) -> void:
	_data[SECTIONS_KEY].append(section_name)


## Removes the section from the list and updates the rest of the scenes.
func remove_section(section_name: String) -> void:
	_data[SECTIONS_KEY].erase(section_name)
	
	# Loop through the _sections cache and remove sections associated with the addresses
	var to_erase := []
	for key in _sections:
		if _sections[key].has(section_name):
			_sections[key].erase(section_name)
			if _sections[key].is_empty():
				to_erase.append(key)
	
	for item in to_erase:
		_sections.erase(item)
	
	# Go through the data and also update the scenes there
	for key in scenes:
		if scenes[key]["sections"].has(section_name):
			scenes[key]["sections"].erase(section_name)


## Adds `section_name` to associate to `scene_address`.
func add_scene_to_section(scene_address: String, section_name: String) -> void:
	if section_name == "All":
		return
	
	if not _sections.has(scene_address):
		_sections[scene_address] = []
	
	if not section_name in _sections[scene_address]:
		_sections[scene_address].append(section_name)

	# Locate the scene in the data and also update it there if it's not already added
	for key in scenes:
		if scenes[key]["value"] == scene_address:
			if section_name not in scenes[key]["sections"]:
				scenes[key]["sections"].append(section_name)
			break


## Removes `section_name` association to `scene_address`.
func remove_scene_from_section(scene_address: String, section_name: String) -> void:
	if not _sections.has(scene_address):
		return

	if section_name in _sections[scene_address]:
		_sections[scene_address].erase(section_name)
	
	if _sections[scene_address].is_empty():
		_sections.erase(scene_address)
	
	# Locate the scene in the data and also update it there if it's not already added
	for key in scenes:
		if scenes[key]["value"] == scene_address:
			if section_name not in scenes[key]["sections"]:
				scenes[key]["sections"].erase(section_name)
			break


## Returns all sections related to `scene_address`.
func get_scene_sections(scene_address: String) -> Array:
	if not _sections.has(scene_address):
		return []
	return _sections[scene_address]


## Returns whether the `scene_address` has sections.
func has_sections(scene_address: String) -> bool:
	return scene_address in _sections and _sections[scene_address] != []

#endregion Section Handler


#region File Save and Load

## Saves all data to the `scenes.gd` file.
func save() -> void:
	# To prevent writing to the file when not necessary, compare the dictionary against the stored file content
	if not has_changes:
		# File is the same as the current data, don't do any unneeded file writing
		return

	var file := FileAccess.open(
		ProjectSettings.get_setting(SceneManagerConstants.SETTINGS_SCENE_PROPERTY_NAME, SceneManagerConstants.DEFAULT_PATH_TO_SCENES),
		FileAccess.WRITE)

	# Generates the scene.gd file with all the scene data
	var write_data: String = SCENE_DATA_HEADER

	# Convert the keys of the dictionary into an enum
	write_data += SCENE_DATA_ENUM + "\n"
	write_data += "enum SceneName \\\n{ \n\tNONE = -1, "

	# Keep track of invalid enums so there aren't blank names that make the generated enum invalid
	var invalid_name := "INVALID"
	var num_invalid: int = 0
	for key: String in _data[SCENE_DATA_KEY].keys():
		if key == "":
			write_data += "\n\t%s%d, " % [invalid_name, num_invalid]
			num_invalid += 1
		else:
			write_data += "\n\t%s, " % key.to_upper()
	
	write_data += "\n}\n\n"

	write_data += SCENE_DATA_DICTIONARY + "\n"
	write_data += "var scenes: Dictionary = \\\n"
	write_data += JSON.new().stringify(_data, "\t") + "\n"
	write_data += SCENE_DATA_END_DICTIONARY + "\n"

	file.store_string(write_data)
	_file_data = _data.duplicate(true)


## Loads all data in the `scenes.gd` file.
func load() -> void:
	_data = _load_file()
	_file_data = _data.duplicate(true)

	# Create the section cache based on the scene data
	_sections.clear()
	for key in scenes:
		for section in scenes[key]["sections"]:
			add_scene_to_section(scenes[key]["value"], section)


# Internal function for loading the data from the `scene.gd` file.
# This is useful for loading previous values before the current values are written to do
# a comparison.
func _load_file() -> Dictionary:
	var data: Dictionary = {}

	if FileAccess.file_exists(ProjectSettings.get_setting(SceneManagerConstants.SETTINGS_SCENE_PROPERTY_NAME,
			SceneManagerConstants.DEFAULT_PATH_TO_SCENES)):
		var file := FileAccess.open(ProjectSettings.get_setting(SceneManagerConstants.SETTINGS_SCENE_PROPERTY_NAME,
				SceneManagerConstants.DEFAULT_PATH_TO_SCENES),
				FileAccess.READ)
		var dictionary := "";
		var in_dictionary := false
		while not file.eof_reached():
			var line := file.get_line()
			if line == SCENE_DATA_END_DICTIONARY:
				in_dictionary = false
			elif line == SCENE_DATA_DICTIONARY:
				in_dictionary = true
				file.get_line() #skip to json
			elif in_dictionary:
				dictionary += line.strip_escapes()

		var json = JSON.new()
		var err = json.parse(dictionary)
		assert (err == OK, "Scene Manager Error: `scenes.gd` File is corrupted.")
		data = json.data
	
	return data

#endregion File Save and Load


# Returns all scenes from the included directories.
func _get_included_scenes() -> Dictionary:
	# Loop through the includes and recursively get all files from the directories.
	# If it's a file, add the file directly.
	var files: Dictionary = {}

	for include_dir: String in includes:
		var dir := DirAccess.open(include_dir)
		if not dir: # If it's a file
			if not FileAccess.file_exists(include_dir):
				print("Couldn't open ", include_dir)
			else:
				if include_dir.get_extension() == "tscn":
					files[include_dir] = include_dir.get_basename().get_file()
				else:
					# Any other file extension isn't handled
					continue
		else:
			var new_files = _get_scenes_helper(include_dir)
			if len(new_files) != 0:
				files.merge(new_files, true)
	
	return files


# Helper recursive function to traversing a directory recursively to storing all relevant files.
func _get_scenes_helper(root_path: String) -> Dictionary:
	var files: Dictionary = {}
	var folders: Array = []
	var dir := DirAccess.open(root_path)
	var original_root_path = root_path
	
	if root_path[len(root_path) - 1] != "/":
		root_path = root_path + "/"
	 
	if dir:
		dir.list_dir_begin() # TODOGODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547

		if dir.file_exists(root_path + ".gdignore"):
			return files
		
		var file_folder := dir.get_next()
		while file_folder != "":
			var exact_address := root_path + file_folder
			if dir.current_is_dir():
				folders.append(file_folder)
			elif file_folder.get_extension() == "tscn":
				files[exact_address] = file_folder.get_basename().get_file()
			
			file_folder = dir.get_next()

		dir.list_dir_end()

		for folder in folders:
			var new_files: Dictionary = _get_scenes_helper(root_path + folder)
			if len(new_files) != 0:
				files.merge(new_files, true)

	return files


# Removes all scenes in the data that is part of the path.
func _remove_scenes(path: String) -> void:
	for scene in _data[SCENE_DATA_KEY].keys():
		if _data[SCENE_DATA_KEY][scene]["value"].begins_with(path):
			_data[SCENE_DATA_KEY].erase(scene)


# Refreshes the scene dictionary with the latest includes when the include path changes.
func _refresh_scenes() -> void:
	var include_scenes: Dictionary = _get_included_scenes()
	
	# Cache the paths currently in the data to use for comparison for the next parts.
	# The address is the key as this will be used for lookup. The scene name was the key
	# will be useful for the removal as the data uses that as the key.
	var data_files := {}
	for key in _data[SCENE_DATA_KEY]:
		data_files[_data[SCENE_DATA_KEY][key]["value"]] = key

	# Loops through the scene addresses in the data to see if there's any scenes that should be
	# removed due to not being in the include paths.
	for address in data_files:
		if not address in include_scenes:
			_data[SCENE_DATA_KEY].erase(data_files[address])
	
	# Subtract the included_scenes with the data_files to find the paths that are not currently
	# in the data. These will be added to the data.
	var scenes_to_add := _dict_subtract(include_scenes, data_files)

	if scenes_to_add.size() == 0:
		return
	
	# Loop through the remaining paths and add these new scenes with default values.
	# Note that the dictionary value is the default scene name derived from the file.
	for address in scenes_to_add:
		var new_data := {
			"sections": [],
			"value": address
		}

		_data[SCENE_DATA_KEY][scenes_to_add[address]] = new_data


# Subtracts two dictionaries and returns the result.
# The left dictionary will be the source and will remove any keys that
# match the right dictionary. Extra keys on the right dictionary will
# not do anything to the left dictionary.
func _dict_subtract(lh: Dictionary, rh: Dictionary) -> Dictionary:
	var result := lh.duplicate()

	for key in lh:
		if key in rh:
			result.erase(key)
	
	return result